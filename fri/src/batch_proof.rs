use std::collections::BTreeMap;

use crypto::{BatchMerkleProof, DefaultRandomCoin, ElementHasher, MerkleTree, RandomCoin};
use math::{batch_inversion, get_power_series, log2, FieldElement, StarkField};
use utils::collections::Vec;

use crate::utils::hash_vec_values;
use crate::{DefaultVerifierChannel, FriOptions, FriProof, FriVerifier};
use human_bytes::human_bytes;

// FRI BATCH OPENING
// ================================================================================================

/// A batch proof of polynomial opening generated by a FRI prover.
///
/// The proof opens a set of polynomials f0, f1, f2, ..., fn, all of the same degree, at a position z
/// To do so we will need just one FRI proof and O(log d) merkle openings to values of size n.
/// The high-level idea is to first commit to an LDE of f0, f1, f2, ..., fn using a Merkle tree.
/// Importantly we commit to all the polynomials together and not to each polynomial individually.
/// Then we fold all the polynomials to create a composite polynomial f = f0 + f1 * alpha + f2 * alpha^2 + ... + fn * alpha^n
/// We then create a commitment to f and carry out a single FRI opening proof.
///
/// Verifier
/// The verifier will verify the FRI opening proof but at the first layer, he will also ask for openings of f0, f1, f2, ..., fn
/// and check that the folding was done correctly at the positions that are opened in the first layer
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct BatchOpening<B, E, H, R>
where
    B: StarkField,
    E: FieldElement,
    H: ElementHasher<BaseField = B>,
    R: RandomCoin<BaseField = B, Hasher = H>,
{
    /// commitments
    pub layer_commitments: Vec<H::Digest>,
    pub poly_commit: H::Digest,
    /// FRI proof for the folded polynomial f = f0 + f1 * alpha + f2 * alpha^2 + ... + fn * alpha^n
    pub folded_fri_proof: FriProof,
    /// Merkle proof for the commitment to the LDE of f0, f1, f2, ..., fn
    pub poly_mt_open: BatchMerkleProof<H>,
    /// positions opened in the FRI proof
    pub positions: Vec<usize>,
    /// Openings of f0, f1, f2, ..., fn at positions that are opened in the first layer of the FRI proof
    /// in the base field
    pub poly_queries: Vec<Vec<B>>,
    /// Openings of folded poly at positions that are opened in the first layer of the FRI proof
    /// in the extension field (since the folding challenge is in the extension field)
    pub folded_poly_queries: Vec<E>,
    /// opening position and the opening of the folded polynomial
    pub open_pos: E,
    pub folded_opening: E,
    /// openings of individual polynomials
    pub poly_openings: BTreeMap<String, E>,
    // todo: openings of all the polynomials at the opening position
    _public_coin: R,
}

// implement a constructor for BatchOpening
impl<B, E, H, R> BatchOpening<B, E, H, R>
where
    B: StarkField,
    E: FieldElement<BaseField = B>,
    H: ElementHasher<BaseField = B>,
    R: RandomCoin<BaseField = B, Hasher = H>,
{
    // CONSTRUCTOR
    // --------------------------------------------------------------------------------------------
    pub fn new(
        layer_commitments: Vec<H::Digest>,
        poly_commit: H::Digest,
        folded_fri_proof: FriProof,
        positions: Vec<usize>,
        poly_mt_open: BatchMerkleProof<H>,
        poly_queries: Vec<Vec<B>>,
        folded_poly_queries: Vec<E>,
        open_pos: E,
        folded_opening: E,
        poly_openings: BTreeMap<String, E>,
    ) -> Self {
        BatchOpening {
            layer_commitments,
            poly_commit,
            folded_fri_proof,
            positions,
            poly_mt_open,
            poly_queries,
            folded_poly_queries,
            open_pos,
            folded_opening,
            poly_openings,
            _public_coin: R::new(&[]),
        }
    }

    // Size
    // --------------------------------------------------------------------------------------------
    pub fn size(&self) -> usize {
        let mut size = 0;
        size += self.layer_commitments.len() * std::mem::size_of::<H::Digest>(); //layer_commitments
        size += std::mem::size_of::<H::Digest>(); //poly_commit
        size += self.folded_fri_proof.size(); //folded_fri_proof

        size += self.poly_mt_open.leaves.len() * std::mem::size_of::<H::Digest>(); //poly_mt_open
        for i in 0..self.poly_mt_open.nodes.len() {
            size += self.poly_mt_open.nodes[i].len() * std::mem::size_of::<H::Digest>();
        }

        size += self.positions.len() * std::mem::size_of::<usize>(); //positions
        for i in 0..self.poly_queries.len() {
            size += self.poly_queries[i].len() * std::mem::size_of::<B>();
        }

        size += self.folded_poly_queries.len() * std::mem::size_of::<E>(); //folded_poly_queries
        size += std::mem::size_of::<E>(); //open_pos
        size += std::mem::size_of::<E>(); //folded_opening

        size += self.poly_openings.len() * std::mem::size_of::<E>(); //poly_openings

        size
    }

    // Verbose version of size
    pub fn vsize(&self) {
        println!("BatchOpening size breakdown:");

        //layer_commitments
        println!(
            "layer_commitments: {}",
            human_bytes((self.layer_commitments.len() * std::mem::size_of::<H::Digest>()) as f64)
        );

        //poly_commit
        println!("poly_commit: {}", std::mem::size_of::<H::Digest>());

        //folded_fri_proof
        println!("folded_fri_proof: {}", self.folded_fri_proof.size());

        //poly_mt_open
        let mut poly_mt_nodes_size = 0;
        for i in 0..self.poly_mt_open.nodes.len() {
            poly_mt_nodes_size +=
                self.poly_mt_open.nodes[i].len() * std::mem::size_of::<H::Digest>();
        }

        println!(
            "poly_mt_open_leaves: {}",
            human_bytes((self.poly_mt_open.leaves.len() * std::mem::size_of::<H::Digest>()) as f64)
        );
        println!(
            "poly_mt_open_nodes: {}",
            human_bytes(poly_mt_nodes_size as f64)
        );

        //positions
        println!(
            "positions: {}",
            human_bytes((self.positions.len() * std::mem::size_of::<usize>()) as f64)
        );

        // poly_queries
        let mut queries_size = 0;
        for i in 0..self.poly_queries.len() {
            queries_size += self.poly_queries[i].len() * std::mem::size_of::<B>();
        }

        println!("poly_queries: {}", human_bytes(queries_size as f64));

        //folded_poly_queries
        println!(
            "folded_poly_queries: {}",
            human_bytes((self.folded_poly_queries.len() * std::mem::size_of::<E>()) as f64)
        );

        //open_pos
        println!("open_pos: {}", std::mem::size_of::<E>());

        //folded_opening
        println!("folded_opening: {}", std::mem::size_of::<E>());

        //poly_openings
        println!(
            "poly_openings: {}",
            human_bytes((self.poly_openings.len() * std::mem::size_of::<E>()) as f64)
        );

        println!("Total size: {}", human_bytes(self.size() as f64));
    }

    pub fn verify(&self, max_degree: usize, options: FriOptions) {
        // verify the batch_merkle_proof
        // first check that the leaves match
        let query_merkle_leaves = hash_vec_values::<H, B>(&self.poly_queries);
        assert_eq!(self.poly_mt_open.leaves, query_merkle_leaves);

        // then check that leaves lead to the root
        MerkleTree::<H>::verify_batch(&self.poly_commit, &self.positions, &self.poly_mt_open)
            .unwrap();

        let mut public_coin: R = RandomCoin::new(&[]);
        public_coin.reseed(self.poly_commit.clone());
        let alpha: E = public_coin.draw().expect("fiat-shamir failed");

        // compute the roots of unity
        let domain_size = (max_degree + 1) * options.blowup_factor();
        let omega = E::BaseField::get_root_of_unity(log2(domain_size));
        let domain = get_power_series(omega, domain_size);
        let domain = domain.iter().map(|x| E::from(*x)).collect::<Vec<_>>();

        // collect domain[positions] in den
        let mut den = Vec::with_capacity(self.positions.len());
        for pos in self.positions.iter() {
            den.push(domain[*pos]);
        }

        // compute den - open_pos using iter and batch invert
        den.iter_mut().for_each(|x| *x -= self.open_pos);
        let den_inv = batch_inversion(&den);

        // check the folded polynomial
        let mut folded_poly_check = vec![E::ZERO; self.positions.len()];
        let mut alpha_pow = E::ONE;
        for j in 0..self.poly_queries[0].len() {
            for i in 0..self.positions.len() {
                folded_poly_check[i] += E::from(self.poly_queries[i][j]) * alpha_pow;
            }
            alpha_pow *= alpha;
        }

        for i in 0..self.positions.len() {
            folded_poly_check[i] = domain[self.positions[i]]
                * (folded_poly_check[i] - self.folded_opening)
                * den_inv[i];
        }

        assert_eq!(folded_poly_check.len(), self.folded_poly_queries.len());
        assert_eq!(folded_poly_check, self.folded_poly_queries);

        let mut folded_opening_check = E::ZERO;
        let mut alpha_pow = E::ONE;
        for (_, &poly_opening) in self.poly_openings.iter() {
            folded_opening_check += alpha_pow * poly_opening;
            alpha_pow *= alpha;
        }
        assert_eq!(folded_opening_check, self.folded_opening);

        // check the FRI proof
        // verify the proof
        let mut channel = DefaultVerifierChannel::<E, H>::new(
            self.folded_fri_proof.clone(),
            self.layer_commitments.clone(),
            domain_size,
            options.folding_factor(),
        )
        .unwrap();

        let mut coin = DefaultRandomCoin::<H>::new(&[]);
        let verifier: FriVerifier<E, DefaultVerifierChannel<E, H>, H, DefaultRandomCoin<H>> =
            FriVerifier::new(&mut channel, &mut coin, options.clone(), max_degree).unwrap();
        verifier
            .verify(&mut channel, &self.folded_poly_queries, &self.positions)
            .unwrap();

        // todo: make sure the positions are computed correctly as the output of fiat-shamir
        // note: this may already be happening in the FRI verifier from winterfell
    }
}
